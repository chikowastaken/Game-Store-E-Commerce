{"ast":null,"code":"import { progress, mix, fillOffset, defaultOffset, noopReturn } from '@motionone/utils';\nimport { getEasingForSegment } from './easing.es.js';\n\nvar clampProgress = function clampProgress(p) {\n  return Math.min(1, Math.max(p, 0));\n};\n\nfunction interpolate(output) {\n  var input = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultOffset(output.length);\n  var easing = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : noopReturn;\n  var length = output.length;\n  /**\n   * If the input length is lower than the output we\n   * fill the input to match. This currently assumes the input\n   * is an animation progress value so is a good candidate for\n   * moving outside the function.\n   */\n\n  var remainder = length - input.length;\n  remainder > 0 && fillOffset(input, remainder);\n  return function (t) {\n    var i = 0;\n\n    for (; i < length - 2; i++) {\n      if (t < input[i + 1]) break;\n    }\n\n    var progressInRange = clampProgress(progress(input[i], input[i + 1], t));\n    var segmentEasing = getEasingForSegment(easing, i);\n    progressInRange = segmentEasing(progressInRange);\n    return mix(output[i], output[i + 1], progressInRange);\n  };\n}\n\nexport { interpolate };","map":{"version":3,"names":["progress","mix","fillOffset","defaultOffset","noopReturn","getEasingForSegment","clampProgress","p","Math","min","max","interpolate","output","input","length","easing","remainder","t","i","progressInRange","segmentEasing"],"sources":["/Users/giorgichikovani/Desktop/e-commerce/node_modules/@motionone/animation/dist/utils/interpolate.es.js"],"sourcesContent":["import { progress, mix, fillOffset, defaultOffset, noopReturn } from '@motionone/utils';\nimport { getEasingForSegment } from './easing.es.js';\n\nconst clampProgress = (p) => Math.min(1, Math.max(p, 0));\nfunction interpolate(output, input = defaultOffset(output.length), easing = noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clampProgress(progress(input[i], input[i + 1], t));\n        const segmentEasing = getEasingForSegment(easing, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexport { interpolate };\n"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,GAAnB,EAAwBC,UAAxB,EAAoCC,aAApC,EAAmDC,UAAnD,QAAqE,kBAArE;AACA,SAASC,mBAAT,QAAoC,gBAApC;;AAEA,IAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAACC,CAAD;EAAA,OAAOC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYD,IAAI,CAACE,GAAL,CAASH,CAAT,EAAY,CAAZ,CAAZ,CAAP;AAAA,CAAtB;;AACA,SAASI,WAAT,CAAqBC,MAArB,EAAwF;EAAA,IAA3DC,KAA2D,uEAAnDV,aAAa,CAACS,MAAM,CAACE,MAAR,CAAsC;EAAA,IAArBC,MAAqB,uEAAZX,UAAY;EACpF,IAAMU,MAAM,GAAGF,MAAM,CAACE,MAAtB;EACA;AACJ;AACA;AACA;AACA;AACA;;EACI,IAAME,SAAS,GAAGF,MAAM,GAAGD,KAAK,CAACC,MAAjC;EACAE,SAAS,GAAG,CAAZ,IAAiBd,UAAU,CAACW,KAAD,EAAQG,SAAR,CAA3B;EACA,OAAO,UAACC,CAAD,EAAO;IACV,IAAIC,CAAC,GAAG,CAAR;;IACA,OAAOA,CAAC,GAAGJ,MAAM,GAAG,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;MACxB,IAAID,CAAC,GAAGJ,KAAK,CAACK,CAAC,GAAG,CAAL,CAAb,EACI;IACP;;IACD,IAAIC,eAAe,GAAGb,aAAa,CAACN,QAAQ,CAACa,KAAK,CAACK,CAAD,CAAN,EAAWL,KAAK,CAACK,CAAC,GAAG,CAAL,CAAhB,EAAyBD,CAAzB,CAAT,CAAnC;IACA,IAAMG,aAAa,GAAGf,mBAAmB,CAACU,MAAD,EAASG,CAAT,CAAzC;IACAC,eAAe,GAAGC,aAAa,CAACD,eAAD,CAA/B;IACA,OAAOlB,GAAG,CAACW,MAAM,CAACM,CAAD,CAAP,EAAYN,MAAM,CAACM,CAAC,GAAG,CAAL,CAAlB,EAA2BC,eAA3B,CAAV;EACH,CAVD;AAWH;;AAED,SAASR,WAAT"},"metadata":{},"sourceType":"module"}